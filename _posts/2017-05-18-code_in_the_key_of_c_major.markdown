---
layout: post
title:  Code (in the Key of C Major)
date:   2017-05-18 18:45:21 -0400
---


In my previous blog post, [*Why Are You Doing This To Yourself?*](http://kyleblee.com/2017/05/02/why_are_you_doing_this_to_yourself/), I explained the reasoning behind my aspiration to become a web developer. In it, I told a narrative which chronicled my roundabout way of arriving here, at [*Flatiron School*](https://flatironschool.com/programs/online-web-developer-career-course/). The truth is, I’ve done quite a bit of bouncing around to arrive at “now”, and in that time I’ve worn more than a few hats. This post—the one you’re reading now—is inspired by a hat I’ve worn for quite a while (music) and a hat that I just recently put on (code).


***Verse***

You see, before I was a wannabe web developer, before I was a brand strategist, before I was a marketing student at *VCU*, before I worked my first shift waiting tables or had my first internship, before *all* of the twists and turns that have occurred in my young adult life: I was a music student at *The University of the Arts*.

Most of my co-workers and new friends don’t know this about me, but music used to be all I cared about. Nowadays, it is something that is still very dear to me, but it has taken a “back seat” for the time being. It’s like some secret, long-term mission that I keep concealed while another mission—AKA, changing careers—is completed, first. It’s this hibernating animal that I feed a little bit every day, to keep it healthy until springtime. You might be wondering what this has to do with code or *Flatiron*? It’s a fair question...

Ever since I wrote my first HTML tag, I have noticed some striking similarities between two disciplines that are seemingly very different, at least on the surface. I realized that the way a musician *thinks*, is really not that far removed from the way a web developer *thinks*. Throughout this post, we’ll see if I can convince you that this surprising parallel exists.

Now that I’ve set the scene, let’s take it to the chorus.


***Chorus***

At first glance, music and code don’t seem to have an awful lot in common. One is auditory, the other is mostly visual. One has been around for centuries, the other is a relatively recent development. One is seen as “creative”, the other is seen as “logical” (though *we* obviously know that coding can indeed be creative). However, when you have a baseline of knowledge in each, you start to see some interesting harmony in the details.

**music theory = syntax and semantics**

In JavaScript and Ruby, there are rules that you must follow in order for the computer to interpret your program correctly. Whether it’s an `end` for every `def` keyword, the specific placement of curly braces, or the need to define a variable before it can be referred to; there are certain standards that must be followed if you want the code to run. These principles of syntax and semantics are similar to the “rules” that musicians follow to build scales, harmony, musical phrases, and entire compositions. In music, these guiding conventions are referred to, broadly, as *music theory*. There are specific relationships between notes that musicians know create certain sounds. If you are playing over a Maj7#11 tonality, you might choose to apply a Lydian phrase because of the characteristic raised fourth. If your piano player lays down an altered dominant, you should avoid natural 9ths and 5ths because you don’t want to rub elbows with any altered tones they might be including.

This comparison can be taken even further, as both disciplines also allow for a certain amount of *flexibility*—some rule bending, you might say. In Ruby, for example, you can often leave things out; like the parentheses around an argument list when calling a method. In JavaScript, you might choose to use a function expression, or be more concise with an arrow function expression. These individualistic choices are even more pronounced in music, where it is commonly said that one of the advantages to learning the rules is having the ability to *break them* in a tasteful and unique way. For example, there isn’t a minor 3rd or flat 5 present in an F7 chord; but it sure sounds funky when a player purposely mixes them into a chromatic line leading to the perfect fifth. Music and programming both have inherent “rules” that must be followed in order for them to be functional; but once you know these rules well enough, you can start to bend them to your liking. Ain't that funky?

<iframe src="https://giphy.com/embed/h0TPbr80IwoP6" width="480" height="313" frameBorder="0" class="giphy-embed" allowFullScreen></iframe><p><a href="https://giphy.com/gifs/sly-stone-and-the-family-h0TPbr80IwoP6"></a></p>

**live sound / recording production = debugging**

During my time at *The University of the Arts*, I also had the opportunity to intern as a Live Sound Technician at the *Caplan Recital Hall*, where UArts ensembles frequently held rehearsals and performances. During this experience, I learned how to follow an audio signal from an input—like a reverb drenched guitar coming out of a Fender Hot Rod—all the way to the final output (a PA system). Along the way, the sound would be routed, boosted, cleaned up, altered, and even recorded. 

Working in this role, you quickly learn how to troubleshoot, on the fly. It is guaranteed that you will have situations (a lot of them…) where the sound is lost somewhere on its journey through the numerous pieces of equipment and cables that it must go through. The input is there, it’s going into the microphone, but… there is nothing happening at the other end. Having the ability to follow the signal step-by-step, until you find the exact spot where things are going wrong, is a large part of the job description.

Does this sound familiar? It should, because this process is *exactly* what developers do every single day when they are debugging code. There is a starting point, a desired ending point or result, and somewhere in the middle things aren’t behaving as expected. Fixing these bugs typically requires starting at the beginning and following the logic all the way through the program, until you find where things are going wrong. Clearly, this linear problem solving is a vital skill to have in both fields.

**songwriting = building a digital product**

If you ask a 10 random people on the street who their favorite songwriter is, you’ll probably get 10 different answers (except for the 2 or 3 “I don’t know”s). I bet you have one, too; and I doubt it’s the same as mine. 

My favorite songwriter is [*Matthew Perryman Jones*](https://www.youtube.com/watch?v=cUefUmX3HMc). There are a few reasons for this, but maybe the most important is that he just... *gets* me. It’s like every song he writes was written with my face taped to his notebook (but in a normal way; like not creepy or anything...). You know what I’m trying to say. You have a songwriter like that, too. This is what writers like Matthew do best: they write compositions that resonate with the emotions and convictions of a specific audience. Their melody, their lyrics, the messages that are communicated in their tunes; it all just hits ya, right in the feels. 

Well, software developers do the same thing, in a way. Sure, there are some huge differences—they are building applications instead of songs, the end goal isn’t to make someone cry or dance (usually), they are meant to solve a problem instead of simply relate to one, etc—but, in principle, both are pieces of intellectual property that are written with a very specific audience in mind. Software developers build products that are useful and intuitive for an intended end user. And, in the same way that a songwriter empathizes with the emotions of their listeners, a developer places themselves inside the heads of their target consumer. This allows them to build a product that is pleasing for the people who will likely be using it. A country lover probably won’t relate much to a punk rock song. Likewise, someone who races their Subaru WRX on the weekend probably won’t have much use for a social network that is geared towards Harley owners. In both industries, peering through the unique lens of the consumer is paramount.

Furthermore, just as every songwriter has their own voice, every developer writes their code in a slightly different way. As seems to be the mantra on nearly every online coding education platform out there: there isn’t one “right” way to achieve a desired result. Just as their are a million ways to write a song, there are a million ways to build an e-commerce platform or a portfolio page or a social network for Harley owners.

<iframe src="https://giphy.com/embed/cA9q5AUOWsnSg" width="480" height="270" frameBorder="0" class="giphy-embed" allowFullScreen></iframe><p><a href="https://giphy.com/gifs/jack-nicholson-motorcycle-easy-rider-cA9q5AUOWsnSg"></a></p>

**improvising a solo = breaking a program down into atomic parts**

Let’s take it to a different genre. Uh one, uh two, uh one, two, three, four (bebop melody plays in the background). When people hear a jazz great like Dexter Gordon improvise, they often say something along the lines, “Wow! It’s amazing how he just makes all of that up on the spot. It’s so effortless for him!” But anyone who has studied jazz knows that this statement is further from the truth than most people might think. Improvisation isn’t like… 100% improvisation. It’s more like 25% improvisation.

The truth is, a legend like Dexter has memorized *thousands upon thousands* of musical phrases (licks, chops, lines, whatever you want to call them). Phrases for different tonalities, for hundreds of specific chord progressions, for different tempos, for different styles or genres, etc. When you hear Dexter play that incredible 5 minute solo, what is actually occurring is the seamless stitching together of phrases that he has digested over years of practice—phrases he can call on, modify for the situation, and organically mold together on the spot.

This concept, of breaking a large problem or task (a solo) into much smaller problems or tasks (bits of musical vocabulary), is extremely similar to the way a developer breaks an application or feature down into small, bite sized, testable bits of code. Pretty cool, right? *Flatiron* tells their students that it’s vital to develop this ability to break something complicated into simple, independent snippets of code. This organized and systematic approach to coding makes the bigger problem feel less intimidating, makes the code more reusable, and ensures that our code is easy for other developers to read.

And the analogy doesn’t stop there! See, Dexter’s bag of tricks is full of *different* phrases for *different* situations. So is a developer’s bag of tricks! Using Bootstrap to quickly implement a responsive image carousel, utilizing media queries to adjust the page’s layout for various screen sizes, applying AJAX to create a single-page application that avoids constant page refreshing; all of these are *different* skills that solve *different* problems. But, they all come together to create useful and intuitive digital products; much like Dexter using an altered dominant lick in the middle of his 2nd chorus. 

***Outro***

So, that wraps up my argument—my realization. Music and code, while seemingly disparate on the surface, actually have quite a bit in common. Both have rules you must follow (with some informed flexibility). Both require linear problem solving. Both benefit from an unwavering focus on the target audience or end user. And finally, both involve breaking a large task into many smaller, atomic parts. 

Maybe that three years of music school wasn’t such a waste afterall...

------------

For your listening pleasure: [*Dexter Gordon - Cheese Cake*](https://www.youtube.com/watch?v=hkyJQcmVtZQ)

If you enjoyed my thoughts on how music is similar to code, you may also enjoy my ramblings on [*Why Brands Should Be More Like Bands*](http://redpegmarketing.com/news/why-brands-should-be-more-like-bands/).

